# Story 3.5.3: Production Environment & Deployment Workflow

Status: ready-for-dev

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a Developer,
I want a hardened production environment on Railway with a controlled deployment promotion workflow,
so that features validated on staging can be safely released to real users.

## Acceptance Criteria

1. **AC1: Railway Production Environment** — Separate Railway environment for production within the same Railway project. Backend and webapp services deployed from the same Dockerfiles as staging (Story 3.5.1). Production-specific environment variables (database, Firebase, API keys). Resource configuration appropriate for production workloads.
2. **AC2: Production Firebase Project** — Separate Firebase project for production (`classlite-prod` or similar). Auth providers configured (Email/Password, Google). Production Firebase Admin SDK credentials stored in Railway production environment. Production Firebase Client SDK config injected at webapp build time.
3. **AC3: Production Postgres** — Dedicated production Postgres instance on Railway (separate from staging). Automated daily backups configured (Railway's built-in backup feature or pg_dump cron). Document restore procedure.
4. **AC4: Domain & SSL** — Custom domain configured for production (both API and webapp). SSL certificates provisioned (Railway handles this automatically with custom domains). CORS configured for production domain. Subdomain strategy documented (e.g., `app.classlite.com`, `api.classlite.com`).
5. **AC5: Deployment Promotion Workflow** — Controlled promotion from staging to production. Push to `develop` → auto-deploy to staging (from Story 3.5.1). Push to `master` → deploy to production. Production deploy requires: all CI checks pass + staging deploy successful. Document the workflow in README.
6. **AC6: Basic Monitoring** — Health check endpoint on backend (`GET /health` or `/api/v1/health`). Railway metrics dashboard for CPU, memory, request count. Application-level logging visible in Railway logs. Error alerting: configure Railway notifications or basic webhook for deploy failures.
7. **AC7: Production Seed** — Minimal production seed: platform admin account only. No test data in production. Separate from staging seed (Story 3.5.2).
8. **AC8: Security Hardening** — Production environment variables never logged or exposed. CORS restricted to production domain only (no wildcards). Rate limiting on API endpoints (basic Fastify rate-limit plugin). Helmet headers on backend (already using Fastify, add `@fastify/helmet`). Content Security Policy headers on webapp nginx config.

## Scope Clarification

**What IS built in this story:**
- Railway production environment configuration
- Production Firebase project
- Production Postgres with backups
- Custom domain and SSL setup
- Deployment workflow: develop → staging, master → production
- Health check endpoint
- Basic monitoring via Railway
- Security hardening (rate limiting, helmet, CSP)
- Production seed script

**What is NOT built (out of scope):**
- APM tools (Datadog, Sentry, etc.) — future enhancement
- Auto-scaling configuration — Railway handles basic scaling
- CDN setup — future optimization
- Blue/green or canary deployments — standard Railway deploy is sufficient
- Load testing — future story
- Comprehensive logging aggregation — Railway logs are sufficient for now

## Tasks / Subtasks

### Task 1: Railway Production Environment (AC: 1)

- [ ] 1.1 Create production environment in the existing Railway project
- [ ] 1.2 Configure backend service (same Dockerfile as staging, production env vars)
- [ ] 1.3 Configure webapp service (same Dockerfile as staging, production build args)
- [ ] 1.4 Configure production Postgres instance (AC: 3)
- [ ] 1.5 Map all environment variables for production (from `.env.example` checklist)
- [ ] 1.6 Verify services start and connect correctly

### Task 2: Production Firebase Project (AC: 2)

- [ ] 2.1 Create production Firebase project
- [ ] 2.2 Configure auth providers (Email/Password, Google)
- [ ] 2.3 Generate production Firebase Admin SDK service account key
- [ ] 2.4 Configure production Firebase Client SDK config
- [ ] 2.5 Set production Firebase credentials as Railway production environment variables
- [ ] 2.6 Verify auth flow works end-to-end on production

### Task 3: Domain & SSL (AC: 4)

- [ ] 3.1 Configure custom domain for webapp (e.g., `app.classlite.com`)
- [ ] 3.2 Configure custom domain for backend API (e.g., `api.classlite.com`)
- [ ] 3.3 Set up DNS records pointing to Railway
- [ ] 3.4 Verify SSL certificates are provisioned and active
- [ ] 3.5 Update backend CORS configuration for production domain
- [ ] 3.6 Update webapp API URL build arg for production domain

### Task 4: Deployment Promotion Workflow (AC: 5)

- [ ] 4.1 Create `.github/workflows/deploy-production.yml`:
  - Trigger: push to `master` branch
  - Jobs: run full CI checks → deploy to Railway production
  - Requires all CI checks to pass
- [ ] 4.2 Configure Railway production deploy tokens as GitHub secrets
- [ ] 4.3 Document the promotion workflow:
  - `develop` branch → staging (auto, from Story 3.5.1)
  - `master` branch → production (auto after CI)
  - Merging `develop` → `master` is the production release trigger
- [ ] 4.4 Test: merge develop to master, verify production deploys

### Task 5: Postgres Backup & Recovery (AC: 3)

- [ ] 5.1 Enable Railway automated backups for production Postgres (daily)
- [ ] 5.2 Document backup schedule and retention policy
- [ ] 5.3 Document restore procedure (Railway UI or `pg_restore`)
- [ ] 5.4 Test: perform a backup and restore to verify procedure works

### Task 6: Monitoring & Health Check (AC: 6)

- [ ] 6.1 Add health check endpoint to backend: `GET /api/v1/health`
  - Returns: `{ status: "ok", timestamp, version }` (200)
  - Checks: database connectivity (simple query)
  - Returns 503 if database unreachable
- [ ] 6.2 Configure Railway health check to hit the endpoint
- [ ] 6.3 Configure Railway deploy failure notifications (email or webhook)
- [ ] 6.4 Verify Railway metrics dashboard shows backend/webapp metrics

### Task 7: Security Hardening (AC: 8)

- [ ] 7.1 Install and configure `@fastify/helmet` on backend for security headers
- [ ] 7.2 Install and configure `@fastify/rate-limit` on backend (basic rate limiting: e.g., 100 req/min per IP)
- [ ] 7.3 Verify CORS is production-domain-only (no wildcard origins)
- [ ] 7.4 Add Content Security Policy headers to webapp nginx.conf
- [ ] 7.5 Verify environment variables are not logged at startup
- [ ] 7.6 Verify `.env` files and Firebase service account keys are in `.gitignore`

### Task 8: Production Seed (AC: 7)

- [ ] 8.1 Create `packages/db/prisma/seed-production.ts`:
  - Create platform admin account only
  - Idempotent (safe to re-run)
- [ ] 8.2 Add `db:seed:production` script to `packages/db/package.json`
- [ ] 8.3 Run production seed after first deploy
- [ ] 8.4 Verify application accessible and admin can log in

## Dev Notes

- Railway supports multiple environments per project — staging and production share the same service definitions but different env vars and databases
- Railway provides automatic SSL for custom domains — no manual cert management
- `@fastify/helmet` and `@fastify/rate-limit` are well-established Fastify plugins, minimal integration effort
- The health check endpoint should NOT be behind auth middleware
- Production seed is intentionally minimal — no test data, just the platform admin to bootstrap
- Deployment to production is via `master` branch push — matches the project's existing branching strategy (main branch is `master`)

## Dependencies

- **Depends on:** Story 3.5.1 (Dockerfiles and staging setup), Story 3.5.2 (migration workflow proven on staging)
- **Blocks:** None (but should be complete before Epic 4 starts)
