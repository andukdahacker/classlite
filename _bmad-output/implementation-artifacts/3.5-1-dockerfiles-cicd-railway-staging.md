# Story 3.5.1: Dockerfiles, CI/CD Enhancement & Railway Staging

Status: ready-for-dev

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a Developer,
I want containerized builds deployed to a Railway staging environment with automated CI/CD,
so that the team can validate features in a real environment before production.

## Acceptance Criteria

1. **AC1: Backend Dockerfile** — Multi-stage Dockerfile for the Fastify backend (`apps/backend`). Stage 1: install dependencies (pnpm workspace with pruning). Stage 2: build TypeScript. Stage 3: production image with minimal footprint. Must generate Prisma Client during build. Entry point runs `prisma migrate deploy` then starts the server (existing prestart hook pattern).
2. **AC2: Webapp Dockerfile** — Multi-stage Dockerfile for the React/Vite frontend (`apps/webapp`). Stage 1: install + build static assets. Stage 2: serve via nginx (or lightweight static server). Build args for `VITE_*` environment variables (API URL, Firebase config).
3. **AC3: Docker Compose** — `docker-compose.yml` at project root for local development parity. Services: backend, webapp, postgres (16), Firebase Auth emulator. Shared network. Volume mounts for development. `.env` file integration.
4. **AC4: Railway Staging Project** — Railway project configured with staging environment. Backend service deployed from Dockerfile. Webapp service deployed from Dockerfile. Internal networking between services. Postgres instance (use existing Railway-hosted Postgres or provision staging-specific). Environment variables configured (all from `.env.example` + Railway-specific).
5. **AC5: Firebase Staging Project** — Separate Firebase project for staging environment (`classlite-staging` or similar). Auth configured with same providers as development. Backend uses staging Firebase Admin SDK credentials. Webapp uses staging Firebase Client SDK config. Document the Firebase project separation in README or deployment docs.
6. **AC6: CI/CD Deployment Extension** — Extend existing `.github/workflows/ci.yml` (or create separate deploy workflow). On push to `develop` branch: run existing CI checks (lint, typecheck, test-unit, test-integration) → deploy to Railway staging. Use Railway GitHub integration or Railway CLI in GitHub Actions. Deployment only triggers after all CI checks pass.
7. **AC7: Staging URL & SSL** — Staging accessible via Railway-provided URL with SSL. Backend API and webapp both accessible. CORS configured for staging domain. Document staging URLs in project README.
8. **AC8: Environment Configuration** — All environment variables from `.env.example` mapped to Railway staging. Secrets (Firebase keys, Resend API key, Gemini API key, Inngest key) stored in Railway environment variables (not committed). `VITE_*` variables injected at webapp build time. `DATABASE_URL` points to staging Postgres.

## Scope Clarification

**What IS built in this story:**
- Backend Dockerfile (multi-stage, production-optimized)
- Webapp Dockerfile (multi-stage, nginx static serving)
- docker-compose.yml for local development
- Railway staging project configuration
- Firebase staging project separation
- GitHub Actions deployment workflow extension
- Environment variable mapping for staging
- Documentation of staging setup

**What is NOT built (out of scope):**
- Production environment (Story 3.5.3)
- Database migration strategy beyond what's needed for staging deploy (Story 3.5.2)
- Production domain/SSL (Story 3.5.3)
- Monitoring and alerting (Story 3.5.3)
- Error boundaries (Story 3.5.4)
- E2E tests (Story 3.5.5)

## Tasks / Subtasks

### Task 1: Backend Dockerfile (AC: 1)

- [ ] 1.1 Create `apps/backend/Dockerfile` with multi-stage build:
  - Stage `base`: Node 20 Alpine, enable corepack pnpm
  - Stage `deps`: Copy workspace root `package.json`, `pnpm-lock.yaml`, `pnpm-workspace.yaml`, and relevant `packages/*/package.json` + `apps/backend/package.json`. Run `pnpm install --frozen-lockfile`.
  - Stage `build`: Copy source code. Run `pnpm --filter=db db:generate` then `pnpm --filter=backend build`.
  - Stage `production`: Copy compiled output + node_modules + generated Prisma client. Expose port. CMD: `node dist/index.js` (prestart hook handles migrations).
- [ ] 1.2 Add `.dockerignore` for backend (exclude node_modules, .env, test files, dist)
- [ ] 1.3 Verify Prisma binary targets include `linux-musl-openssl-3.0.x` (already in schema — confirm works in Alpine container)
- [ ] 1.4 Test backend Docker build locally: `docker build -f apps/backend/Dockerfile .`

### Task 2: Webapp Dockerfile (AC: 2)

- [ ] 2.1 Create `apps/webapp/Dockerfile` with multi-stage build:
  - Stage `base`: Node 20 Alpine, enable corepack pnpm
  - Stage `deps`: Copy workspace package files. Run `pnpm install --frozen-lockfile`.
  - Stage `build`: Copy source. Accept build args for `VITE_API_URL`, `VITE_FIREBASE_*`. Run `pnpm --filter=webapp build`.
  - Stage `production`: nginx Alpine. Copy built static files from build stage to nginx html directory. Copy custom nginx.conf for SPA routing (all routes → index.html).
- [ ] 2.2 Create `apps/webapp/nginx.conf` for SPA routing + security headers
- [ ] 2.3 Add `.dockerignore` for webapp
- [ ] 2.4 Test webapp Docker build locally: `docker build -f apps/webapp/Dockerfile --build-arg VITE_API_URL=http://localhost:4000 .`

### Task 3: Docker Compose for Local Development (AC: 3)

- [ ] 3.1 Create `docker-compose.yml` at project root with services: `backend`, `webapp`, `postgres`, `firebase-emulator`
- [ ] 3.2 Configure Postgres 16 service with health check (match CI configuration)
- [ ] 3.3 Configure volume mounts for development (source code, node_modules excluded)
- [ ] 3.4 Configure shared network and environment variable passing from `.env`
- [ ] 3.5 Test `docker compose up` runs full stack locally

### Task 4: Railway Staging Environment (AC: 4, 7, 8)

- [ ] 4.1 Create Railway project for classlite
- [ ] 4.2 Configure staging environment with backend service (Docker deploy from `apps/backend/Dockerfile`)
- [ ] 4.3 Configure staging environment with webapp service (Docker deploy from `apps/webapp/Dockerfile`)
- [ ] 4.4 Configure Postgres on Railway (staging instance) — or connect to existing hosted Postgres if staging-specific DB exists
- [ ] 4.5 Map all environment variables from `.env.example` to Railway staging environment variables
- [ ] 4.6 Configure internal networking (backend accessible from webapp, database accessible from backend)
- [ ] 4.7 Verify staging URL accessible with SSL
- [ ] 4.8 Configure CORS on backend for staging domain

### Task 5: Firebase Staging Project (AC: 5)

- [ ] 5.1 Create Firebase staging project (e.g., `classlite-staging`)
- [ ] 5.2 Configure Auth providers (Email/Password, Google — matching development)
- [ ] 5.3 Generate staging Firebase Admin SDK service account key
- [ ] 5.4 Configure staging Firebase client SDK config for webapp
- [ ] 5.5 Set staging Firebase credentials as Railway environment variables
- [ ] 5.6 Verify auth flow works end-to-end on staging

### Task 6: CI/CD Deployment Workflow (AC: 6)

- [ ] 6.1 Create `.github/workflows/deploy-staging.yml` (or extend `ci.yml`):
  - Trigger: push to `develop` branch
  - Jobs: run CI checks → deploy backend to Railway → deploy webapp to Railway
  - Use Railway CLI or GitHub integration for deployment
- [ ] 6.2 Configure Railway deploy tokens as GitHub repository secrets
- [ ] 6.3 Ensure deployment only runs after all CI checks (lint, typecheck, test) pass
- [ ] 6.4 Test: push to `develop`, verify CI runs and staging deploys automatically
- [ ] 6.5 Document deployment workflow in project README

## Dev Notes

- Prisma schema already has `binaryTargets = ["native", "linux-musl-openssl-3.0.x", "rhel-openssl-3.0.x"]` — Alpine containers use musl
- Backend `start` script already has `prestart: prisma migrate deploy` — this runs migrations on container start
- pnpm workspace requires careful Docker layer caching — copy package manifests first, install, then copy source
- Railway supports Dockerfile deployments natively — no buildpacks needed
- The existing `.github/workflows/ci.yml` has 5 jobs. Deployment should be a separate workflow or a final job that depends on all CI jobs passing
- `.env.example` documents all required environment variables — use as Railway config checklist
